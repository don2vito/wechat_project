
-- 步骤一：比较基准点的获取

WITH a_t AS (
		SELECT
			"跨年重复时间段的时长问题"."ID",
			"跨年重复时间段的时长问题"."year",
			start_time,
			end_time,
			MAX ( end_time ) OVER ( PARTITION BY "跨年重复时间段的时长问题"."ID", "跨年重复时间段的时长问题"."year" ORDER BY start_time,end_time ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING ) AS std_edt 
		FROM
		"跨年重复时间段的时长问题" 
	) ,
	
-- 李四	2023	2023-12-01 09:00:00	2023-12-15 19:00:00	
-- 李四	2023	2023-12-10 19:00:00	2023-12-21 19:30:20	2023-12-15 19:00:00
-- 李四	2023	2023-12-22 09:00:00	2023-12-25 10:15:08	2023-12-21 19:30:20
-- 王五	2023	2023-12-01 09:00:00	2023-12-01 14:15:05	
-- 王五	2023	2023-12-10 19:00:00	2023-12-20 19:30:20	2023-12-01 14:15:05
-- 张三	2022	2022-12-01 09:00:00	2023-01-01 00:00:00	
-- 张三	2022	2022-12-10 19:00:00	2022-12-21 19:30:20	2023-01-01 00:00:00
-- 张三	2023	2023-01-01 00:00:00	2023-01-21 19:30:20	
-- 张三	2023	2023-01-01 19:30:20	2023-01-31 21:30:29	2023-01-21 19:30:20
-- 张三	2023	2023-02-01 09:30:20	2023-02-05 10:30:55	2023-01-31 21:30:29
	
	
-- 步骤二：将时间断开的打标记,即当前条的开始时间大于上一条的结束时间,认定为时长不连续,出现空隙,打标记

b_t AS (
	SELECT a_t."ID",
	  a_t."year",
		start_time,
		end_time,
	CASE WHEN start_time > std_edt THEN 1 ELSE 0 END AS stage_flag 
	FROM
		a_t
) ,

-- 李四	2023	2023-12-01 09:00:00	2023-12-15 19:00:00	0
-- 李四	2023	2023-12-10 19:00:00	2023-12-21 19:30:20	0
-- 李四	2023	2023-12-22 09:00:00	2023-12-25 10:15:08	1
-- 王五	2023	2023-12-01 09:00:00	2023-12-01 14:15:05	0
-- 王五	2023	2023-12-10 19:00:00	2023-12-20 19:30:20	1
-- 张三	2022	2022-12-01 09:00:00	2023-01-01 00:00:00	0
-- 张三	2022	2022-12-10 19:00:00	2022-12-21 19:30:20	0
-- 张三	2023	2023-01-01 00:00:00	2023-01-21 19:30:20	0
-- 张三	2023	2023-01-01 19:30:20	2023-01-31 21:30:29	0
-- 张三	2023	2023-02-01 09:30:20	2023-02-05 10:30:55	1


-- 步骤三：将打好标记的每个连续时间段分组,利用 sum() over() 开窗区分开每个连续时间段

c_t AS (
	SELECT b_t."ID",
	  b_t."year",
		start_time,
		end_time,
		SUM ( stage_flag ) OVER ( PARTITION BY b_t."ID",b_t."year" ORDER BY start_time ) stage_flag 
	FROM
		b_t
) ,

-- 李四	2023	2023-12-01 09:00:00	2023-12-15 19:00:00	0
-- 李四	2023	2023-12-10 19:00:00	2023-12-21 19:30:20	0
-- 李四	2023	2023-12-22 09:00:00	2023-12-25 10:15:08	1
-- 王五	2023	2023-12-01 09:00:00	2023-12-01 14:15:05	0
-- 王五	2023	2023-12-10 19:00:00	2023-12-20 19:30:20	1
-- 张三	2022	2022-12-01 09:00:00	2023-01-01 00:00:00	0
-- 张三	2022	2022-12-10 19:00:00	2022-12-21 19:30:20	0
-- 张三	2023	2023-01-01 00:00:00	2023-01-21 19:30:20	0
-- 张三	2023	2023-01-01 19:30:20	2023-01-31 21:30:29	0
-- 张三	2023	2023-02-01 09:30:20	2023-02-05 10:30:55	1


-- 步骤四：每个组取最大的 end_time - 最小的 start_time 即为这个连续时间段的去重时长

d_t AS (
	SELECT
		c_t."ID",
		c_t."year",
		stage_flag,
		MAX ( end_time ) - MIN ( start_time ) AS stage_duration 
	FROM
		c_t 
	GROUP BY
		c_t."ID",
		c_t."year",
		stage_flag
) , 

-- 李四	2023	0	20 days 10:30:20
-- 张三	2023	1	4 days 01:00:35
-- 王五	2023	0	05:15:05
-- 李四	2023	1	3 days 01:15:08
-- 张三	2022	0	30 days 15:00:00
-- 张三	2023	0	30 days 21:30:29
-- 王五	2023	1	10 days 00:30:20


-- 步骤五：将每个时间段去重后的时长相加,得到总时长

e_t AS (
	SELECT
		d_t."ID",
		d_t."year",
		SUM ( stage_duration ) AS sum_duration 
	FROM
		d_t 
	GROUP BY
		d_t."ID",
		d_t."year"
	ORDER BY
		d_t."ID",
		d_t."year"
)

-- 李四	2023	23 days 11:45:28
-- 王五	2023	10 days 05:45:25
-- 张三	2022	30 days 15:00:00
-- 张三	2023	34 days 22:31:04
	
	
	SELECT * FROM e_t;
